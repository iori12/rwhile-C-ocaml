-------------------------------------------------------------------------------
-- A grammer of R-WHILE
-------------------------------------------------------------------------------
--
-- Variables   ∋ X, Y ::= X0 | X1 | ...
-- Expressions ∋ E, F ::= X | d | cons E F | hd E | tl E | =? E F | eval ID(E)
-- Patterns    ∋ Q, R ::= X | d | (Q.R) | call ID(Q) | uncall ID(Q)
-- Commands    ∋ C, D ::= X ^= E | Q <= R | C; D
--                      | if E then C else D fi F | from E do C loop D until F
-- Programs    ∋ P    ::= { proc ID(Q) C; return (R) | func ID(Q) return (E) }*
--
-------------------------------------------------------------------------------

entrypoints Program, Val ;


-------------------------------------------------------------------------------
-- Program
-------------------------------------------------------------------------------

Prog.  Program ::= [Proc] ;
separator Proc ";" ;

Proc.  Proc ::= "proc" RIdent "(" Pat ")" [Com] "return" Pat ;
Func.  Proc ::= "func" RIdent "(" Pat ")" Fexp ;
-- separator RIdent "," ;


-------------------------------------------------------------------------------
-- Command
-------------------------------------------------------------------------------

CAsn.  Com ::= RIdent "^=" Exp ;                            -- Reversible assignment
CRep.  Com ::= Pat "<=" Pat ;                               -- Reversible replacement
CCond. Com ::= "if" Exp ThenBranch ElseBranch "fi" Exp ;    -- Reversible conditional
CLoop. Com ::= "from" Exp DoBranch LoopBranch "until" Exp ; -- Reversible loop
CShow. Com ::= "show" Exp ;                                 -- Show command (for debugging use)
terminator Com ";";

BThen.     ThenBranch ::= "then" [Com] ;
BThenNone. ThenBranch ::= ;

BElse.     ElseBranch ::= "else" [Com] ;
BElseNone. ElseBranch ::= ;

BDo.       DoBranch ::= "do" [Com] ;
BDoNone.   DoBranch ::= ;

BLoop.     LoopBranch ::= "loop" [Com] ;
BLoopNone. LoopBranch ::= ;


-------------------------------------------------------------------------------
-- Function's Expression      -- '
-------------------------------------------------------------------------------

FIf.     Fexp  ::= "if" Exp "then" Fexp "else" Fexp ;
Freturn. Fexp  ::= "return" Exp ;

-------------------------------------------------------------------------------
-- Expression
-------------------------------------------------------------------------------

ENot.  Exp  ::= "not" Exp1 ;
EAtom. Exp  ::= "atom" Exp1 ;
ECons. Exp  ::= "cons" Exp1 Exp1 ;
EHd.   Exp  ::= "hd" Exp1 ;
ETl.   Exp  ::= "tl" Exp1 ;
Ecall. Exp  ::= "eval" RIdent "(" Exp ")" ;
EEq.   Exp  ::= "=?" Exp1 Exp1 ;     -- Equality check
ELt.   Exp  ::= "<" Exp1 Exp1 ;
ELe.   Exp  ::= "<=" Exp1 Exp1 ;
EGt.   Exp  ::= ">" Exp1 Exp1 ;
EGe.   Exp  ::= ">=" Exp1 Exp1 ;
EAnd.  Exp  ::= "&&" Exp1 Exp1 ;
EOr.   Exp  ::= "||" Exp1 Exp1 ;
EVar.  Exp1 ::= Variable ;
EVal.  Exp1 ::= Val ;
coercions Exp 1;


-------------------------------------------------------------------------------
-- Pattern
-------------------------------------------------------------------------------

PCons.   Pat ::= "(" Pat "." Pat ")" ;
PVar.    Pat ::= Variable ;
PAtom.   Pat ::= Atom ;
PNil.    Pat ::= "nil" ;
PCall.   Pat ::= "call" RIdent "(" Pat ")" ;
PUncall. Pat ::= "uncall" RIdent "(" Pat ")" ;
-- coercions Pat 1;


-------------------------------------------------------------------------------
-- Value
-------------------------------------------------------------------------------

VNil.  Val  ::= "nil" ;
VAtom. Val  ::= Atom ;          -- ex. 'a, 'loop
VCons. Val  ::= "(" Val "." Val ")";
-- coercions Val 1 ;


-------------------------------------------------------------------------------
-- Misc
-------------------------------------------------------------------------------

Var.   Variable  ::= RIdent;

token RIdent upper (letter | digit | '-' | '\'')*;  -- ex. X, REVERSE, INV-REVERSE
token Atom '\'' (digit | letter)+;                  -- ex. 'val, '32, 

comment "(*" "*)" ;
