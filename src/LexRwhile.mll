(* This ocamllex file was machine-generated by the BNF converter *)
{
open ParRwhile
open Lexing

let symbol_table = Hashtbl.create 12
let _ = List.iter (fun (kwd, tok) -> Hashtbl.add symbol_table kwd tok)
                  [(";", SYMB1);("(", SYMB2);(")", SYMB3);("^=", SYMB4);("<=", SYMB5);("=?", SYMB6);("<", SYMB7);(">", SYMB8);(">=", SYMB9);("&&", SYMB10);("||", SYMB11);(".", SYMB12)]

let resword_table = Hashtbl.create 21
let _ = List.iter (fun (kwd, tok) -> Hashtbl.add resword_table kwd tok)
                  [("atom", TOK_atom);("call", TOK_call);("cons", TOK_cons);("do", TOK_do);("else", TOK_else);("eval", TOK_eval);("fi", TOK_fi);("from", TOK_from);("func", TOK_func);("hd", TOK_hd);("if", TOK_if);("loop", TOK_loop);("nil", TOK_nil);("not", TOK_not);("proc", TOK_proc);("return", TOK_return);("show", TOK_show);("then", TOK_then);("tl", TOK_tl);("uncall", TOK_uncall);("until", TOK_until)]


let unescapeInitTail (s:string) : string =
  let rec unesc s = match s with
      '\\'::c::cs when List.mem c ['\"'; '\\'; '\''] -> c :: unesc cs
    | '\\'::'n'::cs  -> '\n' :: unesc cs
    | '\\'::'t'::cs  -> '\t' :: unesc cs
    | '\"'::[]    -> []
    | c::cs      -> c :: unesc cs
    | _         -> []
  (* explode/implode from caml FAQ *)
  in let explode (s : string) : char list =
      let rec exp i l =
        if i < 0 then l else exp (i - 1) (s.[i] :: l) in
      exp (String.length s - 1) []
  in let implode (l : char list) : string =
      let res = Buffer.create (List.length l) in
      List.iter (Buffer.add_char res) l;
      Buffer.contents res
  in implode (unesc (List.tl (explode s)))

let incr_lineno (lexbuf:Lexing.lexbuf) : unit =
    let pos = lexbuf.lex_curr_p in
        lexbuf.lex_curr_p <- { pos with
            pos_lnum = pos.pos_lnum + 1;
            pos_bol = pos.pos_cnum;
        }
}

let l = ['a'-'z' 'A'-'Z' '\192' - '\255'] # ['\215' '\247']    (*  isolatin1 letter FIXME *)
let c = ['A'-'Z' '\192'-'\221'] # ['\215']    (*  capital isolatin1 letter FIXME *)
let s = ['a'-'z' '\222'-'\255'] # ['\247']    (*  small isolatin1 letter FIXME *)
let d = ['0'-'9']                (*  digit *)
let i = l | d | ['_' '\'']          (*  identifier character *)
let u = ['\000'-'\255']           (* universal: any character *)
let rsyms =    (* reserved words consisting of special symbols *)
            ";" | "(" | ")" | "^=" | "<=" | "=?" | "<" | ">" | ">=" | "&&" | "||" | "."
let rident = c (l | d | '-' | '\'')*
let atom = '\'' (d | l)+

rule token =
  parse "(*" ((u # ['*']) | '*' (u # [')']))* '*'* "*)" {token lexbuf}
      | rsyms {let id = lexeme lexbuf in try Hashtbl.find symbol_table id with Not_found -> failwith ("internal lexer error: reserved symbol " ^ id ^ " not found in hashtable")}
      | rident {let l = lexeme lexbuf in try Hashtbl.find resword_table l with Not_found -> TOK_RIdent l}
      | atom {let l = lexeme lexbuf in try Hashtbl.find resword_table l with Not_found -> TOK_Atom l}
      | l i* {let l = lexeme lexbuf in try Hashtbl.find resword_table l with Not_found -> TOK_Ident l}
      | d+ {let i = lexeme lexbuf in TOK_Integer (int_of_string i)}
      | d+ '.' d+ ('e' ('-')? d+)? {let f = lexeme lexbuf in TOK_Double (float_of_string f)}
      | '\"' ((u # ['\"' '\\' '\n']) | ('\\' ('\"' | '\\' | '\'' | 'n' | 't')))* '\"' {let s = lexeme lexbuf in TOK_String (unescapeInitTail s)}
      | '\'' ((u # ['\'' '\\']) | ('\\' ('\\' | '\'' | 'n' | 't'))) '\'' {let s = lexeme lexbuf in TOK_Char s.[1]}
      | [' ' '\t'] {token lexbuf}
      | '\n' {incr_lineno lexbuf; token lexbuf}
      | eof {TOK_EOF}
