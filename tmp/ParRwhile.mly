/* This ocamlyacc file was machine-generated by the BNF converter */
%{
open AbsRwhile
open Lexing


%}

%token TOK_call TOK_cons TOK_do TOK_else TOK_fi TOK_from TOK_hd TOK_if TOK_loop TOK_nil TOK_proc TOK_return TOK_show TOK_then TOK_tl TOK_until

%token SYMB1 /* ; */
%token SYMB2 /* ( */
%token SYMB3 /* ) */
%token SYMB4 /* ^= */
%token SYMB5 /* <= */
%token SYMB6 /* =? */
%token SYMB7 /* . */

%token TOK_EOF
%token <string> TOK_Ident
%token <string> TOK_String
%token <int> TOK_Integer
%token <float> TOK_Double
%token <char> TOK_Char
%token <string> TOK_RIdent
%token <string> TOK_Atom

%start pProgram
%type <AbsRwhile.program> pProgram


%%
pProgram : program TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };


program : proc_list { Prog $1 } 
;

proc_list : /* empty */ { []  } 
  | proc { (fun x -> [x]) $1 }
  | proc SYMB1 proc_list { (fun (x,xs) -> x::xs) ($1, $3) }
;

proc : TOK_proc rIdent SYMB2 rIdent SYMB3 com SYMB1 TOK_return SYMB2 rIdent SYMB3 { Proc ($2, $4, $6, $10) } 
;

com : com SYMB1 com { CSeq ($1, $3) } 
  | rIdent SYMB4 exp { CAsn ($1, $3) }
  | pat SYMB5 pat { CRep ($1, $3) }
  | TOK_if exp thenBranch elseBranch TOK_fi exp { CCond ($2, $3, $4, $6) }
  | TOK_from exp doBranch loopBranch TOK_until exp { CLoop ($2, $3, $4, $6) }
  | TOK_show exp { CShow $2 }
;

thenBranch : TOK_then com { BThen $2 } 
  | /* empty */ { BThenNone  }
;

elseBranch : TOK_else com { BElse $2 } 
  | /* empty */ { BElseNone  }
;

doBranch : TOK_do com { BDo $2 } 
  | /* empty */ { BDoNone  }
;

loopBranch : TOK_loop com { BLoop $2 } 
  | /* empty */ { BLoopNone  }
;

exp : TOK_cons exp1 exp1 { ECons ($2, $3) } 
  | TOK_hd exp1 { EHd $2 }
  | TOK_tl exp1 { ETl $2 }
  | SYMB6 exp1 exp1 { EEq ($2, $3) }
  | exp1 {  $1 }
;

exp1 : variable { EVar $1 } 
  | valT { EVal $1 }
  | SYMB2 exp SYMB3 {  $2 }
;

pat : TOK_cons pat1 pat1 { PCons ($2, $3) } 
  | pat1 {  $1 }
;

pat1 : variable { PVar $1 } 
  | valT { PVal $1 }
  | TOK_call rIdent SYMB2 rIdent SYMB3 { PCall ($2, $4) }
  | SYMB2 pat SYMB3 {  $2 }
;

valT : TOK_nil { VNil  } 
  | atom { VAtom $1 }
  | SYMB2 valT SYMB7 valT SYMB3 { VCons ($2, $4) }
;

variable : rIdent { Var $1 } 
;


rIdent : TOK_RIdent { RIdent ($1)};
atom : TOK_Atom { Atom ($1)};


